---
title: 数据库设计——范式
date: 2017-07-31 17:24:24
categories: 计算机
tags: [Database]
---

## 解释

首先要明白”范式（NF）”是什么意思。**范式（NF）**：符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度，粗略的理解为一张数据表的表结构所符合的某种设计标准的级别。
数据库范式分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在设计关系型数据库时，最多考虑到BCNF就够了。符合高一级范式的设计，必定符合低一级范式。

## 第一范式（1NF）

**1NF**：符合1NF的关系中的每个属性都不可再分，是所有关系型数据库的最基本要求。
**关系和关系模式的的区别**：类似于面向对象程序设计中“类”和“对象”的区别。“关系”是“关系模式”的一个实例，可以理解“关系”是一张数据库的表，“关系模式”是这张数据表的表结构。

<!-- more -->

不符合1NF范的表
{% asset_img 1.png %}
符合规范的表
{% asset_img 2.png %}

仅仅符合1NF设计，忍让会存在冗余过大、插入异常、删除异常、修改异常的问题。
{% asset_img 3.png %}

根据三种关系完整性约束的实体完整性要求，关系中的码所包含的任意一个属性都不能为空，所有属性的组合也不能重复。

**码**：关系中的某个属性或某几个属性的组合，用于区分每个元组（“元组”可以理解为一张表中的每条记录，也就是每一行）

正因为仅符合1NF的数据库设计存在着这样那样的问题，需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。

## 第二范式（2NF）

2NF在1NF的基础之上，消除了非主属性对码的部分函数依赖。

**函数依赖：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作X->Y**。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也是“函数依赖”名字的由来，类似于y = f（x），在x的值确定的情况下，y的值一定是确定的。

例如：成绩记录表中找不到任何一条记录，它们的学号相同对应的名称不同，所以可以说姓名函数依赖于学号，写作:
  * 学号->姓名
  * 系名->系主任
  * 学号->系主任
  * (学号，课名)->分数

从“函数依赖”这个概念展开，还会有三个概念：

### 完全函数依赖
在一张表中，若X->Y，且对于X的任何一个真子集（例如学号 课名）（假如属性组X包含超过一个属性的话，），X'->Y不成立，那么称Y对于X完全函数依赖，写作：
  * {% asset_img 4.png %}
  * 学号F->姓名
  * (学号，课名)F->分数(注：因为同一个的学号对用的分数不确定，同一个课明对应的分数不确定)

### 部分函数依赖
假如Y函数依赖于X，但同时Y并不完全函数依赖于X，那么称Y部分函数依赖于X，写作：
  * {% asset_img 5.png %}
  * (学号，课名)->姓名

### 传递函数依赖
假如Z函数依赖于Y，且Y函数依赖于X（Y不包含于X，且X不函数依赖于Y），可以称Z传递函数依赖于X，写作：
  * {% asset_img 6.png %}

### 码
假设K为某表中的一个属性或属性组，若除K之外的所有属性都完全函数依赖于K（必须是完全函数依赖），则称K为候选码，简称码。通俗的理解为：假如当K确定的情况下，除该表k之外的所有属性的值也就随之确定，那么K就是码，一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中一个码作为主码）

例如：（学号、课名）这个属性组就是码，该表中有且仅有这一个码（假设所有课程没有重名的）

### 非主属性
包含在任何一个码中的属性称为主属性
  * 主属性：学号、课名
  * 非主属性：姓名、系名、系主任、成绩

判断是否符合2NF就是判断数据表中是否存在非主属性对于码的部分函数依赖。
### 判断方法：
  * 找出数据表中的**码**
  * 根据第一步得到的码，找出所有的**主属性**
  * 数据表中，出去所有的主属性，剩下的就都是**非主属性**了
  * 查看是否存在非主属性对码的**部分函数依赖**

对于成绩表，根据前面所说的四步，我们可以这么做：

**第一步**：
  * 查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。
  * 查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。
  * ...
  * 查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。

看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“**完全**函数依赖”）
表中所有的函数依赖关系：
{% asset_img 7.jpg %}
这一步完成以后，可以得到，码只有一个，就是（**学号、课名**）。

**第二步**：主属性有两个：**学号** 与 **课名**

**第二步**： 主属性有两个：**学号** 与 **课名**

**第三步**： 非主属性有四个：**姓名、系名、系主任、分数**

**第四步**： 对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名** 对码**（学号，课名）**的部分函数依赖。 对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 **系名** 对码**（学号，课名）**的部分函数依赖。 对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性 对码**（学号，课名）**的部分函数依赖。

存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。
为了让表3符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是**将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。**

选课（学号，课名，分数）
学生（学号，姓名，系名，系主任）

先来判断以下，选课表与学生表，是否符合了2NF的要求？

对于选课表，其码是（学号，课名），主属性是学号和课名，非主属性是分数，学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。对于学生表，其码是学号，主属性是学号，非主属性是姓名、系名和系主任，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。

图表示了模式分解以后的新的函数依赖关系：
{% asset_img 8.jpg %}

下表表示了模式分解以后新的数据：
{% asset_img 9.jpg %}

现在来看一下，进行同样的操作，是否还存在着之前的那些问题？
  * 李小明转系到法律系 只需要修改一次李小明对应的系的值即可。——有改进
  * 数据冗余是否减少了？ 学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进
  * 删除某个系中所有的学生记录 该系的信息仍然全部丢失。——无改进
  * 插入一个尚无学生的新系的信息。 因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进

所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性**系主任**对于码**学号**的**传递函数依赖**。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。

## 第三范式（3NF） 

3NF在2NF的基础上，**消除了对非主属性对于吗的传递函数依赖**。也就是说，如果存在非主属性对于码存在传递函数依赖，则不符合3NF的要求。

对于**选课**表，主码为（学号，课名），主属性为**学号**和**课名**，非主属性只有一个，为分数，不可能存在传递函数依赖，所以**选课**表的设计，符合3NF的要求。

对于**学生**表，主码为**学号**，主属性为**学号**，非主属性为**姓名、系名**和**系主任**。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性**系主任**对于码**学号**的传递函数依赖，所以**学生**表的设计，不符合3NF的要求。。

为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：
选课（学号，课名，分数）
学生（学号，姓名，系名）
系（系名，系主任）

对于**选课**表，符合3NF的要求，之前已经分析过了。
对于**学生**表，码为**学号**，主属性为**学号**，非主属性为**系名**，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。

对于**系**表，码为**系名**，主属性为**系名**，非主属性为**系主任**，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。

新的函数依赖关系如图：
{% asset_img 10.jpg %}
新的数据表如表：
{% asset_img 11.jpg %}

现在来看一下，进行同样的操作，是否还存在着之前的那些问题？
  * 删除某个系中所有的学生记录 该系的信息不会丢失。——有改进
  * 插入一个尚无学生的新系的信息。 因为系表与学生表目前是独立的两张表，所以不影响。——有改进
  * 数据冗余更加少了。——有改进

**结论** 由此可见，符合3NF要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。


原文：https://www.zhihu.com/question/24696366/answer/29189700
来源：知乎